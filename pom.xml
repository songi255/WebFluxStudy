<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.5</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <!-- parent에 spring-boot-starter-parent 를 등록했다. 무슨 역할일까?
        미리 정의된 여러 속성정보, 의존관계, 플러그인들을 상속받는다.
        미리 정의된 의존관계가 가장 핵심인데, 전체 Spring portfolio 와 Jackson, Netty, Project Reactor 등 다양한 서브파티도 포함된다.
        다른 라이브러리가 필요하면 pom에 추가만 하면 Spring Boot가 Parent를 바탕으로 적합한 버전을 찾아 사용할 수 있게 해준다.
        즉, Boot의 새 버전이 나왔다면, Parent 버전 하나만 갱신하면 포함된 모든 라이브러리도 적합한 버전으로 자동 업그레이드되는 것이다.
    -->

    <groupId>com.greglturnquist</groupId>
    <artifactId>hacking-spring-boot-reactive</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>WebfluxStudy</name>
    <description>WebfluxStudy</description>
    <properties>
        <java.version>11</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <!-- scope가 test인 의존관계들. -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <!-- spring-boot-starter-test에는 다음이 포함된다.
             AssertJ, Hamcrest, HTMLUnit, JSONassert, JsonPath, JUnit5, Mockito, Selenium, Spring Test, XMLUnit-->
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-test</artifactId>
            <scope>test</scope>
        </dependency>
        <!-- 전통적인 블로킹 방식은 spring-boot-starter-data-mongodb. 아래 4가지 의존관계를 포함한다.
            1. spring-boot-starter
            2. spring-data-mongodb : blocking 방식 driver 제외된 spring mongodb
            3. mongodb-driver-reactivestreams : mongodb 공식 reactive stream driver
            4. reactor-core : project reactor core module
        -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-mongodb-reactive</artifactId>
        </dependency>

        <!-- 내장형 mongodb 도구. test 에 주로 사용하며 application 초기 설계 단계에서 data store 로 사용할 수 있다. -->
        <dependency>
            <groupId>de.flapdoodle.embed</groupId>
            <artifactId>de.flapdoodle.embed.mongo</artifactId>
        </dependency>

        <!-- reactive가 아닌 전통적 mongodb driver. -->
        <dependency>
            <groupId>org.mongodb</groupId>
            <artifactId>mongodb-driver-sync</artifactId>
        </dependency>

        <!-- Spring Boot 의 개발자도구이다. 포함된 기능은 다음과 같다.
                - App restart / reload
                    - 개발자가 작성한 코드를 하나의 ClassLoader 로 로딩하고, third party lib 는 별도의 Loader 로 로딩한다.
                    - App 이 재시작되면 개발자가코드 ClassLoader는 재시작되지만, third party 로드했던 Loader는 그대로 남아, 훨씬 빠르다.
                        - 참고로 모든것을 새로 시작하는 것은 cold 방식이라고 한다.
                        - 하지만 한계가 있기 때문에, reload 개선효과를 최대로 끌어내려면 JRebel 같은 Java Agent Solution 이 필요할 수도 있다.
                - 환경설정정보 기본값 제공
                - autoconfiguration 변경사항 로깅
                - 정적 자원 제외
                - LiveReload 지원
         -->
        <!--
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        -->
        <!-- optional 은 이 dependecy는 실제 상용운영코드에는 추가되지 않는다는 의미이다. -->
        <!-- spring devtools는 App 시작방법을 몰래 훔쳐본다.
                - java -jar 명령이나 클라우드 서비스 제공자가 사용하는 특별한 classLoader를 통해 App 실행 시, 이번 실행은 상용이다 라고 판단하고 기능을 비활성화한다.
                - 하지만 IDE 에서 실행되거나, Maven의 spring-boot:run 명령으로 실행되면 해당 실행은 개발모드라고 판단하고 개발자도구의 모든 기능을 활성화한다.
         -->

    </dependencies>

    <build>
        <!-- Maven plugin. Java build 도구이다.
            Jar 스펙은 다른 Jar파일을 내부에 embed 하는 표준을 정해놓지 않았다. 그래서 선언된 모든 의존관계를
            이 플러그인이 최종 Jar에 집어넣고, 클래스 로딩용 일부코드도 포함시킨다. 게다가 Jar을 executable 하게 만들어준다.

            third party lib Jar을 풀어 Class 파일을 최종 Jar에 넣는 작업을 Shading 이라고 한다.
            다른 플러그인들은 안정적이지 않으며, 라이선스에 저촉될 수 있다.
         -->
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
